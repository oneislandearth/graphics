!function(n,e){if("object"==typeof exports&&"object"==typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var t=e();for(var a in t)("object"==typeof exports?exports:n)[a]=t[a]}}(self,(function(){return(()=>{"use strict";var __webpack_modules__={102:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"Animation\": () => (/* reexport */ Animation),\n  \"Camera\": () => (/* reexport */ Camera),\n  \"Engine\": () => (/* reexport */ Engine),\n  \"Material\": () => (/* reexport */ Material),\n  \"Mesh\": () => (/* reexport */ Mesh),\n  \"Scene\": () => (/* reexport */ Scene)\n});\n\n;// CONCATENATED MODULE: ./src/modules/engine.js\n\n\n// Define the graphic engine\n\nclass Engine {\n  \n  // Define the engine\n  constructor(canvas, scene, options) {\n\n    // Bind the name\n    this.name = `@oneisland/graphics`;\n\n    // Bind the canvas\n    this.canvas = document.querySelector(canvas);\n\n    // Bind the width and height\n    this.canvas.width = window.innerWidth;\n    this.canvas.height = window.innerHeight;\n\n    // Dynamically resize the canvas if the window changes size\n    window.addEventListener('resize', () => {\n\n      // Bind the width and height\n      this.canvas.width = window.innerWidth;\n      this.canvas.height = window.innerHeight;\n\n      // Resize the viewport\n      this.context.viewport(0, 0, window.innerWidth, window.innerHeight);\n    });\n    \n    // Create the context\n    this.context = this.canvas.getContext('webgl2');\n    // , { preserveDrawingBuffer: true });\n\n    // Throw an error if there is no context\n    if (!this.context) throw new Error('WebGL2 is not supported by your browser');\n\n    // Initialise the scene\n    this.scene = scene({ canvas: this.canvas, context: this.context });\n\n    // Define the fps\n    this.fps = 0;\n\n    // Define the past time\n    let past = 0;\n\n    // Run the render loop\n    const render = async(now) => {\n\n      // Compute present in seconds\n      now *= 0.001;\n\n      // Compute the difference in time\n      const delta = (now - past);\n\n      // Update the past\n      past = now;\n\n      // Update the fps\n      this.fps = (1 / delta);\n\n      // Await the scene\n      const scene = await this.scene;\n      \n      // Render the scene\n      scene.render(delta);\n\n      // Run the render loop\n      requestAnimationFrame(render);\n    };\n\n    // Run the render loop\n    requestAnimationFrame(render);\n\n    // Handle the options\n    if (options && options.fps) this.showFPS();\n  }\n\n  // Show the fps\n  showFPS() {\n\n    // Create the DOM element\n    const element = document.createElement('small');\n\n    // Define the fps styles\n    const styles = {\n      'position': 'fixed',\n      'top': '10px',\n      'left': '10px', \n      'font-family': '\\'Lato\\', sans-serif', \n      'padding': '5px',\n      'color': 'rgb(240, 240, 240)',\n      'background-color': 'rgb(20, 20, 20, 0.5)'\n    };\n\n    // Apply the styles\n    Object.assign(element.style, styles);\n\n    // Append the element after the canvas\n    this.canvas.parentNode.insertBefore(element, this.canvas);\n\n    // Set the interval to update the fps every 200ms\n    setInterval(() => {\n      \n      // Update the text content\n      element.textContent = `FPS: ${this.fps.toFixed()}`;\n    }, 100);\n  }\n}\n;// CONCATENATED MODULE: ./src/modules/math/core.js\n// Describe a function to round the a number (6dp default)\nconst round = (number, decimals = 6) => Number(parseFloat(number).toFixed(decimals));\n\n// Describe the add function\nconst add = (a, b) => round(a + b);\n\n// Describe the subtract function\nconst subtract = (a, b) => round(a - b);\n\n// Describe the multiply function\nconst multiply = (a, b) => round(a * b);\n\n// Describe the divide function\nconst divide = (a, b) => round(a / b);\n\n// Describe the negate function\nconst negate = (value) => multiply(value, -1);\n\n// Describe the half function\nconst half = (value) => multiply(value, 0.5);\n\n// Describe the double function\nconst core_double = (value) => multiply(value, 2);\n\n// Describe the third function\nconst third = (value) => divide(value, 3);\n\n// Describe the absolute function\nconst abs = (value) => round(Math.abs(value));\n\n// Describe the min function\nconst min = (a, b) => round(Math.min(a, b));\n\n// Describe the max function\nconst max = (a, b) => round(Math.max(a, b));\n\n// Describe the square root function\nconst sqrt = (value) => round(Math.sqrt(value));\n\n// Describe the power function\nconst pow = (value, exponent) => round(Math.pow(value, exponent));\n\n// Describe the square function\nconst square = (value) => pow(value, 2);\n\n// Define the cube function\nconst cube = (value) => pow(value, 3);\n\n// Define the norm function\nconst norm = (value) => sqrt(sum(value.map(v => square(v))));\n\n// Describe the equal function\nconst equal = (a, b) => abs(a - b) <= (max(abs(a), abs(b)) * 1e-4);\n\n// Describe the sum function\nconst sum = (values) => round(values.reduce((sum, value) => add(sum, value), 0));\n\n// Map out all the values\nconst map = (values, fn) => values.map(fn);\n\n// Map the values from one set into the other\nconst mapKeys = (keys, values) => (\n  map(keys, set => (\n    map(set, i => values[i])\n  ))\n);\n\n// Compute the cross product of two vectors\nconst cross = (a, b) => {  \n  \n  // Extract the vector components\n  const [ax, ay, az] = a;\n  const [bx, by, bz] = b;\n\n  // Return the cross product\n  return [\n    subtract(multiply(ay, bz), multiply(az, by)),\n    subtract(multiply(az, bx), multiply(ax, bz)),\n    subtract(multiply(ax, by), multiply(ay, bx))\n  ];\n};\n\n// Compute the unit of a vector\nconst unit = (value) => {\n\n  // Compute the norm of the vector\n  const magnitude = norm(value);\n\n  // Return the unitized vector\n  return value.map(v => v / magnitude);\n};\n\n// Clamp a value between min and max\nconst clamp = (a, min, max) => Math.min(Math.max(a, min), max);\n\n// Define the trig functions\nconst cos = (a) => round(Math.cos(a));\nconst acos = (a) => round(Math.cos(a));\nconst sin = (a) => round(Math.sin(a));\nconst asin = (a) => round(Math.sin(a));\n;// CONCATENATED MODULE: ./src/modules/math/vec3.js\n// Import the required core functions;\n\n\n// Vectorizes an operation\nconst vectorize = (operation) => (a, b) => ([\n  operation(a[0], b[0]),\n  operation(a[1], b[1]),\n  operation(a[2], b[2])\n]); \n\n// Define the vec3 functions\nconst vec3 = (x, y, z) => ([x || 0, y || 0, z || 0]);\n\n// Define the zeroes function\nvec3.zeros = [0, 0, 0];\n\n// Define the ones function\nvec3.ones = [1, 1, 1];\n\n// Define the right function\nvec3.right = [1, 0, 0];\n\n// Define the left function\nvec3.left = [-1, 0, 0];\n\n// Define the up function\nvec3.up = [0, 1, 0];\n\n// Define the down function\nvec3.down = [0, -1, 0];\n\n// Define the back function\nvec3.back = [0, 0, 1];\n\n// Define the forward function\nvec3.forward = [0, 0, -1];\n\n// Define the add function\nvec3.add = (a, b) => vectorize(add)(a, b);\n\n// Define the subtract function\nvec3.subtract = (a, b) => vectorize(subtract)(a, b);\n\n// Define the multiply function\nvec3.multiply = (a, b) => vectorize(multiply)(a, b);\n\n// Define the divide function\nvec3.divide = (a, b) => vectorize(divide)(a, b);\n\n// Define the function to expand a scalar value to a vec3\nvec3.expand = (scalar) => [scalar, scalar, scalar];\n\n// Define the magnitude / norm of a vector\nvec3.magnitude = (a) => (\n  sqrt(\n    sum(\n      map(a, v => square(v))\n    )\n  )\n);\n\n// Define the unit of a vector\nvec3.unit = (a) => (\n  vec3.divide(\n    a,\n    vec3.expand(\n      vec3.magnitude(a)\n    )\n  )\n);\n\n// Define the dot product function\nvec3.dot = (a, b) => (\n  sum(\n    vec3.multiply(a, b)\n  )\n);\n\n// Define the cross product function\nvec3.cross = (a, b) => (\n  ([ax, ay, az], [bx, by, bz]) => (\n    [\n      subtract(\n        multiply(ay, bz), \n        multiply(az, by)\n      ),\n      subtract(\n        multiply(az, bx), \n        multiply(ax, bz)\n      ),\n      subtract(\n        multiply(ax, by), \n        multiply(ay, bx)\n      )\n    ]\n  )\n)(a, b);\n\n// Compute the angles between two vectors\nvec3.angle = (a, b) => (\n  acos(\n    divide(\n      vec3.dot(a, b),\n      multiply(\n        vec3.magnitude(a),\n        vec3.magnitude(b)\n      )\n    )\n  )\n);\n;// CONCATENATED MODULE: ./src/modules/math/polygon.js\n// Import the require core functions\n\n\n// Import the vec3 functions\n\n\n// Compute the area of a triangle\nconst polygon = {};\n\n// Compute the normal of a polygon\npolygon.normal = ([a, b, c]) => (\n  vec3.unit(\n    vec3.cross(\n      vec3.subtract(a, c),\n      vec3.subtract(b, c)\n    )\n  )\n);\n\n// Compute the area of a triangle\npolygon.area = ([a, b, c]) => (\n  half(\n    vec3.magnitude(\n      vec3.cross(\n        vec3.subtract(a, b), \n        vec3.subtract(a, c)\n      )\n    )\n  )\n);\n;// CONCATENATED MODULE: ./src/modules/math/polyhedron.js\n\n\n// Import the vec3 modules\n\n\n\n// Define a polyhedron logic\nconst polyhedron = (vertices, faces) => (\n  mapKeys(faces, vertices)\n);\n\n// Compute the area of a polyhedron\npolyhedron.area = (polygons) => (\n  sum(\n    map(polygons, ([a, b, c]) => (\n      polygon.area([a, b, c])\n    ))\n  )\n);\n\n// Compute the volume of a polyhedron\npolyhedron.volume = (polygons) => (\n  third(\n    sum(\n      map(polygons, ([a, b, c]) => (\n        multiply(\n          vec3.dot(a, polygon.normal([a, b, c])),\n          polygon.area([a, b, c])\n        )\n      ))\n    )\n  )\n);\n\n// Define the vertices for the cube\nconst vertices = [\n  [-1, -1, 1],\n  [ 1, -1, 1],\n  [ 1, -1, -1],\n  [-1, -1, -1],\n  [-1, 1, 1],\n  [ 1, 1, 1],\n  [ 1, 1, -1],\n  [-1, 1, -1]\n];\n\n// Define the faces for the cube\nconst faces = [\n  [2, 3, 0],\n  [0, 1, 2],\n  [0, 3, 7],\n  [7, 4, 0],\n  [4, 0, 1],\n  [1, 5, 4],\n  [3, 2, 6],\n  [6, 7, 3],\n  [5, 1, 2],\n  [2, 6, 5],\n  [7, 4, 5],\n  [5, 6, 7]\n];\n\nconst poly = polyhedron(vertices, faces);\n\npolyhedron.volume(poly);\npolyhedron.area(poly);\n;// CONCATENATED MODULE: ./src/modules/math/index.js\n\n\n\n\n;// CONCATENATED MODULE: ./src/modules/core/listeners.js\n// Create a pointer listener\nconst pointer = {};\n\n// Create a mouse-down / touch-start listener\npointer.select = (element, handler) => {\n\n  // Bind the mouse listener to the element\n  element.addEventListener('mousedown', (e) => handler(e), { passive: true });\n\n  // Bind the touch listener to the element\n  element.addEventListener('touchstart', (e) => handler(e.touches[0]), { passive: true });\n};\n\n// Create a mouse-up / touch-end listener\npointer.release = (element, handler) => {\n\n  // Bind the mouse listener to the element\n  element.addEventListener('mouseup', (e) => handler(e), { passive: true });\n\n  // Bind the touch listener to the element\n  element.addEventListener('touchend', (e) => handler(e.touches[0]), { passive: true });\n\n  // Bind the touch listener to the element\n  element.addEventListener('touchcancel', (e) => handler(e.touches[0]), { passive: true });\n};\n\n// Create a mouse-move / touch-move listener\npointer.move = (element, handler) => {\n\n  // Bind the mouse listener to the element\n  element.addEventListener('mousemove', (e) => handler(e), { passive: true });\n\n  // Bind the touch listener to the element\n  element.addEventListener('touchmove', (e) => handler(e.touches[0]), { passive: true });\n};\n\n// Create a mouse-move / touch-move listener\npointer.scroll = (element, handler) => {\n\n  // Bind the mouse listener to the element\n  element.addEventListener('wheel', (e) => handler(e), { passive: true });\n\n  // Bind the touch listener to the element\n  // element.addEventListener('touchmove', (e) => handler(e.touches[0]), { passive: true });\n};\n\n// Export the pointer handler\n\n;// CONCATENATED MODULE: ./src/modules/camera/input.js\n// Import the required math\n\n\n// Import the events listeners\n\n\n// Describe the handler\nconst cameraInputManager = ((camera) => {\n\n  // Use strict  \n  \n  'use-strict';\n\n  // Define the canvas and context from the scene\n  const canvas = camera.scene.canvas;\n  const context = camera.scene.context;\n\n  // Define the past pointer positions\n  let px = null; \n  let py = null;\n\n  // Define the last change in positions\n  let dx = null;\n  let dy = null;\n\n  // Define the moving status\n  let moving = false;\n\n  // Define the start movement function\n  const startMovement = (e) => {\n\n    // Update the start positions\n    px = e.clientX;\n    py = e.clientY;\n\n    // Update the moving flag to true\n    moving = true;\n  };\n\n  // Define the on movement function to rotate a camera\n  const onMovement = (e) => {\n\n    // Get the current pointer position\n    const x = e.clientX;\n    const y = e.clientY;\n\n    // Check if the pointer is moving\n    if (moving) {\n\n      // Compute the change in positions\n      dx = divide(subtract(x, px), context.canvas.width);\n      dy = divide(subtract(y, py), context.canvas.height);\n\n      // Compute the change in alpha\n      const alphad = multiply(6, dx);\n\n      // Compute the change in beta\n      const betad = multiply(6, dy);\n\n      // Update the camera\n      updateCameraView(alphad, betad, 0, false);\n\n      // Update the previous positions\n      px = x;\n      py = y;\n    }\n  };\n\n  // Stop the movement\n  const stopMovement = (e) => {\n\n    // Compute the change in alpha\n    const alphad = multiply(30, dx);\n\n    // Compute the change in beta\n    const betad = multiply(30, dy);\n\n    // Update the camera\n    updateCameraView(alphad, betad, 0, true);\n    \n    (moving = false);\n  };\n\n  // Update the camera view\n  const updateCameraView = (alphad = 0, betad = 0, radiusd = 0, quad = false) => {\n\n    // If not quadratic\n    if (quad == false) {\n\n      //\n      // console.log('non-quadratic');\n\n      return requestAnimationFrame(() => {\n        \n        // Update the alpha and beta values\n        camera.alpha = add(camera.alpha, alphad);\n        camera.beta = clamp(add(camera.beta, betad), (-Math.PI / 1.99), (Math.PI / 1.99));\n        camera.radius = clamp(add(camera.radius, radiusd), 0, 20);\n      });\n    }\n\n    // Compute the quadratic steps\n    const quadraticSteps = (value, steps) => {\n\n      // Create an empty array\n      const values = Array(steps).fill(0);\n      \n      // Compute a value\n      const step = (i) => (-value * (i / steps) * ((i / steps) - 2) + 0);\n    \n      // Map the values out\n      return values.map((v, i) => ((i > 0) ? step(i) - step(i - 1) : 0));\n    };\n\n    // Compute the quadratic easing\n    const easeAlpha = quadraticSteps(alphad, 20);\n    const easeBeta = quadraticSteps(betad, 20);\n    const easeRadius = quadraticSteps(radiusd, 20);\n\n    // Run 10 easings\n    for (let i = 0; i < 20; i++) {\n\n      setTimeout(() => requestAnimationFrame(() => {\n        \n        // Update the alpha and beta values\n        camera.alpha = add(camera.alpha, easeAlpha[i]);\n        camera.beta = clamp(add(camera.beta, easeBeta[i]), (-Math.PI / 1.99), (Math.PI / 1.99));\n        camera.radius = clamp(add(camera.radius, easeRadius[i]), 0, 20);\n      }), i * 50);\n    }\n  };\n\n  // Bind the pointer events\n  pointer.select(canvas, startMovement);\n  pointer.move(canvas, onMovement);\n  pointer.release(canvas, stopMovement);\n  pointer.scroll(canvas, e => updateCameraView(0, 0, (e.deltaY * 0.001), true));\n});\n;// CONCATENATED MODULE: ./src/modules/camera/camera.js\n// Import the required math\n\n\n// Import the input handler\n\n\n// Describe the basic field of view camera\nclass Camera {\n\n  // Desribe the constructor\n  constructor(name, { scene, ...options }) {\n\n    // Bind the name\n    this.name = name;\n\n    // Bind the scence\n    this.scene = scene;\n\n    // Bind the field of view (60 deg)\n    this.fov = options.fov || Math.PI * 0.25;\n\n    // Bind the near clipping plane distance\n    this.near = options.near || 0.01;\n\n    // Bind the far clipping plane distance\n    this.far = options.far || 1000;\n\n    // Bind the radius\n    this.radius = options.radius || 20;\n\n    // Bind the alpha angle\n    this.alpha = 0;\n\n    // Bind the beta angle\n    this.beta = (Math.PI / 8);\n\n    // Define the min zoom range\n    this.min = (this.scale / 2);\n\n    // Define the max zoom range\n    this.max = (this.scale * 2);  \n\n    // Define the camera position\n    this.origin = [0, 0, 0];\n\n    // Define the camera target\n    this.target = [0, 0, 0];\n\n    // Define the current zoom\n    this.zoom = 1;\n\n    // Handle mousewheel zoom\n    cameraInputManager(this);\n  }\n\n  // Define the aspect ratio\n  get aspectRatio() {\n\n    // Return the aspect ratio of the canvas\n    return (this.scene.context.drawingBufferWidth / this.scene.context.drawingBufferHeight);\n  }\n\n  // Compute the eye for the camera\n  get eye() {\n\n    // Compute the radius (as an exponential would be faster)\n    const radius = this.radius;\n\n    // Compute the new eye values\n    return [\n      add(this.target[0], multiply(radius, multiply(cos(this.alpha), cos(this.beta)))),\n      add(this.target[1], multiply(radius, sin(this.beta))),\n      add(this.target[2], multiply(radius, multiply(sin(this.alpha), cos(this.beta))))\n    ];\n  }\n\n  // Define the camera matrix\n  get view() {\n\n    // Compute and return the look at camera matrix\n    return mat4.lookAt(new Float32Array(16), this.eye, this.target, [0, 1, 0]);\n  }\n\n  // Return the camera projection matrix\n  get projection() {\n\n    // Compute the range inverse\n    const riv = (1 / (this.near - this.far));\n\n    // Define the computed values\n    const f = (1.0 / Math.tan(this.fov / 2));\n    const a = (f / this.aspectRatio);\n    const k = ((this.near + this.far) * riv);\n    const l = -1;\n    const o = (this.near * this.far * riv * 2);\n\n    // Return the projection\n    return new Float32Array([\n      a, 0, 0, 0,\n      0, f, 0, 0,\n      0, 0, k, l,\n      0, 0, o, 0\n    ]);\n  }\n\n  // Define the zoom function\n  zoom(delta) {\n\n    // Adjust the zoom\n    const zoom = (this.scale + delta);\n\n    // Compute the zoom out\n    if (delta < 0) this.scale = (zoom > this.min) ? zoom : this.min;\n\n    // Compute the zoom in\n    if (delta > 0) this.scale = (zoom < this.max) ? zoom : this.max;\n  }\n}\n;// CONCATENATED MODULE: ./src/modules/scene.js\n// Import the camera module\n\n\n// Define the scene generator\nclass Scene {\n\n  constructor(name, { canvas, context }) {\n\n    // Bind the name\n    this.name = name;\n\n    // Bind the graphics canvas\n    this.canvas = canvas;\n\n    // Bind the grapics context\n    this.context = context;\n\n    // Create the materials\n    this.materials = [];\n\n    // Create the meshes\n    this.meshes = [];\n\n    // Bind the default camera\n    this.camera = new Camera('camera', { scene: this });\n\n\n    // // Enable depth testing\n    context.enable(context.DEPTH_TEST);\n    \n    // // Allow close items to obscure far items\n    context.depthFunc(context.LEQUAL);\n    // Context.depthRange(0, 1);\n    // context.depthMask(true);\n\n    context.clearColor(0, 0, 0, 0);\n\n    // Clear the canvas AND the depth buffer.\n    context.clear(context.COLOR_BUFFER_BIT | context.DEPTH_BUFFER_BIT);\n\n    // Context.enable(context.CULL_FACE);\n    // context.cullFace(context.BACK);\n\n    // Generate the world matrix\n    this.world = mat4.create();\n\n    // Render the scene\n    this.render();\n  }\n\n  // // Return the identity matrix for transforms\n  // get world() {\n  //   return new Float32Array([\n  //     1, 0, 0, 0, \n  //     0, 1, 0, 0, \n  //     0, 0, 1, 0,\n  //     0, 0, 0, 1\n  //   ]);\n  // }\n\n  // Add a mesh\n  addMesh(mesh) {\n\n    // Bind the mesh\n    this.meshes = mesh;\n  }\n\n  // Render the scene\n  render() {\n\n    // Iterate through each of the meshes\n    for (const mesh of this.meshes) {\n\n      // Render the mesh\n      mesh.render();\n    }\n  }\n}\n;// CONCATENATED MODULE: ./src/modules/material/shader.js\n\n\n// Define the fragement shader\nclass Shader {\n\n  // Define the constructor\n  constructor(source, type) {\n\n    // Bind the shader source\n    this.source = source;\n\n    // Bind the shader type\n    this.type = type;\n  }\n\n  // Compile the shader\n  compile(context) {\n\n    // Create the shader context\n    const shader = context.createShader(this.type);\n      \n    // Bind the source to the shader object\n    context.shaderSource(shader, this.source);\n      \n    // Compile the shader program\n    context.compileShader(shader);\n      \n    // Check if the shader compiled correctly\n    if (!context.getShaderParameter(shader, context.COMPILE_STATUS)) {\n  \n      // Delete the shader\n      // context.deleteShader(shader);\n  \n      // Throw an error as the shader failed to compile\n      throw new Error(`Shader failed to compile: ${context.getShaderInfoLog(shader)}`);\n    }\n      \n    // Return the compiled shader\n    return shader;\n  }\n}\n;// CONCATENATED MODULE: ./src/data/shaders/vertex.shader\n/* harmony default export */ const vertex_shader = (\"// Define the position, normal and color fiekds\\nattribute vec4 position;\\nattribute vec3 normal;\\n\\n// The transformation matrices\\nuniform mat4 world;\\nuniform mat4 model;\\nuniform mat4 view;\\nuniform mat4 projection;\\nuniform mat4 normalMatrix;\\n\\n// Lighting position\\nuniform vec3 light;\\n\\n// Pass the brightness to the fragment shader\\nvarying vec3 vertexNormal;\\nvarying vec3 worldNormal;\\n\\nvoid main() {\\n\\n  // Compute the vertex normal\\n  vertexNormal = normal;\\n  \\n  // Compute the world normal\\n  worldNormal = (normalMatrix * vec4(normal, 1.0)).xyz;\\n\\n  // Compute the position\\n  gl_Position = projection * view * model * world * position;\\n}\");\n;// CONCATENATED MODULE: ./src/data/shaders/fragment.shader\n/* harmony default export */ const fragment_shader = (\"precision mediump float;\\n\\n// Define the mesh color\\nuniform vec4 color;\\n\\n// The normals\\nvarying vec3 vertexNormal;\\nvarying vec3 worldNormal;\\n\\nvoid main() {\\n\\n  // Define the light position\\n  vec3 light = vec3(0, 1, 0);\\n\\n  // Compute the ambient color\\n  vec3 ambient = 0.3 * color.xyz;\\n\\n  // Compute the diffuse colour\\n  vec3 diffuse = 0.7 * color.xyz * clamp(dot(vertexNormal, light), 0.0, 1.0 );\\n\\n  // Compute the brightness\\n  float brightness = clamp(dot(vertexNormal, light), 0.0, 1.0 );\\n\\n  // Compute the colour\\n  // gl_FragColor = vec4(ambient + diffuse, color.w);\\n\\n\\n  // Bind the color\\n  // gl_FragColor = vec4(color.xyz * brightness, color.w);\\n  gl_FragColor = vec4(vertexNormal, 1.0);\\n}\");\n;// CONCATENATED MODULE: ./src/modules/material/material.js\n// Import the shader class\n\n\n// Import the default shaders\n\n\n\n// Define the material class\nclass Material {\n\n  // Define the material path\n  constructor(name, scene) {\n\n    // Bind the name\n    this.name = name;\n\n    // Bind the scene\n    this.scene = scene;\n\n    // Generate a hash 8 characters long\n    this.hash = Math.random(Date.now()).toString(16).substring(6, 14);\n\n    // Get the context from the scene\n    const context = this.scene.context;\n\n    // Create the vertex shader\n    const vertexShader = new Shader(vertex_shader, context.VERTEX_SHADER);\n\n    // Create the fragment shader\n    const fragmentShader = new Shader(fragment_shader, context.FRAGMENT_SHADER); \n\n    // Bind the shaders\n    this.vertexShader = vertexShader;\n    this.fragmentShader = fragmentShader;\n\n    // Bind the material to the scene\n    this.scene.materials.push(this);\n\n    // Generate the material application\n    this.generate();\n  }\n\n  // Set the vertex shader\n  setVertexShader(shader) {\n\n    // Bind the vertex shader\n    this.vertexShader = shader;\n\n    // Generate the program again\n    this.generate();\n  }\n\n  // Set the fragment shader\n  setFragmentShader(shader) {\n\n    // Bind the fragment shader\n    this.fragmentShader = shader;\n\n    // Generate the program again\n    this.generate();\n  }\n\n  // Generate the shader program\n  generate() {\n\n    // Select the scene context\n    const context = this.scene.context;\n\n    // Create a shader program\n    this.shader = context.createProgram();\n\n    // Attach the shaders to the program\n    context.attachShader(this.shader, this.vertexShader.compile(context));\n    context.attachShader(this.shader, this.fragmentShader.compile(context));\n\n    // Link the shader program\n    context.linkProgram(this.shader);\n\n    // Check if the shader program was created correctly    \n    if (!context.getProgramParameter(this.shader, context.LINK_STATUS)) {\n\n      // Throw an error if the program failed\n      throw new Error(`Shader program failed to created: ${context.getProgramInfoLog(this.shader)}`);\n    }\n  }\n\n  // Select the shader program locations\n  get locations() {\n\n    // Select the scene context\n    const context = this.scene.context;\n\n    // Use the shader program\n    context.useProgram(this.shader);\n\n    // Define the locations\n    return {\n      world: context.getUniformLocation(this.shader, 'world'),\n      model: context.getUniformLocation(this.shader, 'model'),\n      view: context.getUniformLocation(this.shader, 'view'),\n      projection: context.getUniformLocation(this.shader, 'projection'),\n      normalMatrix: context.getUniformLocation(this.shader, 'normalMatrix'),\n      light: context.getUniformLocation(this.shader, 'light'),\n      color: context.getUniformLocation(this.shader, 'color'),\n      position: context.getAttribLocation(this.shader, 'position'),\n      normal: context.getAttribLocation(this.shader, 'normal')\n    };\n  }\n}\n;// CONCATENATED MODULE: ./src/modules/mesh.js\n// Import the color material\n\n\n// Import the required math functions\n\n\n// Define the mesh\nclass Mesh {\n\n  constructor(name, { vertices, faces, scene, ...options }) {\n\n    // Bind the name\n    this.name = name;\n\n    // Bind the scene\n    this.scene = scene;\n\n    // Create the default material\n    this.material = new Material(`${name}-material`, this.scene);\n\n    // Define the position\n    this.position = (options.position ? options.position : [0, 0, 0]);\n\n    // Define the rotation\n    this.angle = 1;\n\n    // Define the meshes\n    this.animations = [];\n\n    // Update the data\n    this.update({ vertices, faces });\n    \n    // Store this mesh in the scene meshes\n    this.scene.meshes.push(this);\n  }\n\n  // Rotate the y axis\n  rotate() {\n    this.angle += (((Math.PI * 2) / 360) * 1);\n  }\n\n  // Return model matrix for transforms\n  get model() {\n\n    // Create an identity matrix\n    const model = mat4.create();\n\n    // Translate the position to the model position\n    mat4.translate(model, model, this.position);\n\n    // Return the model matrix\n    return model;\n  }\n\n  // Bind the data for the faces\n  update({ vertices, faces }) {\n\n    // Bind the vertices\n    this.vertices = vertices;\n\n    // Bind the faces\n    this.faces = faces;\n\n    // Define the positions\n    this.positions = [];\n\n    // Define the normals\n    this.normals = [];\n\n    // Define the indices\n    this.indices = [];\n\n    // Add the position and normal\n    const addPosition = (vertex, normal) => {\n\n      // Extract the vertex components\n      const [vx, vy, vz] = vertex;\n\n      // Extract the normal components\n      const [nx, ny, nz] = normal;\n      \n      // Iterate through the existing positions\n      for (let i = 0; i < this.positions.length; i++) {\n\n        // Extract the position components\n        const [px, py, pz] = this.positions[i];\n\n        // Check if the vertex matches the position\n        if (equal(px, vx) && equal(py, vy) && equal(pz, vz)) {\n\n          // Extract the components of the normal of the stored position\n          const [vnx, vny, vnz] = this.normals[i];\n\n          // Check if the planes match for the vertex\n          if (equal(vnx, nx) && equal(vny, ny) && equal(vnz, nz)) {\n\n            // Return the index of this vertex as it has already been computed for this plane\n            return i;\n          }\n        }\n      }\n\n      // Store the normal\n      this.normals.push(normal);\n\n      // Store the vertex and return the index\n      return (this.positions.push(vertex) - 1);\n    };\n\n    // Iterate through the faces extracting the face indexes\n    for (const [f0, f1, f2] of this.faces) {\n\n      // Extract the vertices\n      const v0 = this.vertices[f0];\n      const v1 = this.vertices[f1];\n      const v2 = this.vertices[f2];\n\n      // Compute the new vectors\n      const v0v2 = vec3.subtract(v0, v2); \n      const v1v2 = vec3.subtract(v1, v2);\n\n      // Compute the unit vector using the unit of the cross product of the new vectors\n      const normal = unit(cross(v0v2, v1v2));\n\n      if (normal.find(v => v == -1)) continue;\n\n      // Add the vertices to the positions (one for each face)\n      const iv0 = addPosition(v0, normal);\n      const iv1 = addPosition(v1, normal);\n      const iv2 = addPosition(v2, normal);\n\n      // Add the position indexes to the indices\n      this.indices.push(iv0, iv1, iv2);\n    }\n  }\n\n  // Generate the face from vertex data\n  static fromVertexData({ positions, normals, indices }) {\n\n    // Bind the positions\n    this.positions = positions;\n\n    // Bind the normals\n    this.normals = normals;\n\n    // Bind the indices\n    this.indices = indices;\n  }\n\n  // Define the buffers\n  get buffers() {\n\n    // Select the engine context\n    const context = this.scene.context;\n\n    // Create the positions buffer\n    const positionsBuffer = context.createBuffer();\n\n    // Bind the positions buffer\n    context.bindBuffer(context.ARRAY_BUFFER, positionsBuffer);\n    \n    // Add the positions data to the positions buffer\n    context.bufferData(context.ARRAY_BUFFER, new Float32Array(this.positions.flat()), context.STATIC_DRAW);\n\n    // Create the normals buffer\n    const normalsBuffer = context.createBuffer();\n    \n    // Bind the positions buffer\n    context.bindBuffer(context.ARRAY_BUFFER, normalsBuffer);\n    \n    // Add the normals data to the normals buffer\n    context.bufferData(context.ARRAY_BUFFER, new Float32Array(this.normals.flat()), context.STATIC_DRAW);\n    \n    // Define the indices buffer\n    const indicesBuffer = context.createBuffer();\n    \n    // Bind the indices buffer\n    context.bindBuffer(context.ELEMENT_ARRAY_BUFFER, indicesBuffer);\n    \n    // Add the indices data to the indices buffer\n    context.bufferData(context.ELEMENT_ARRAY_BUFFER, new Uint16Array(this.indices), context.STATIC_DRAW);\n\n    // Return the buffers\n    return {\n      positions: positionsBuffer,\n      normals: normalsBuffer,\n      indices: indicesBuffer\n    };\n  }\n\n  // Define the add material class\n  addMaterial(material) {\n\n    // Bind the material\n    this.material = material;\n  }\n\n  // Add the animation\n  addAnimation(animation) {\n\n    // Bind the animation\n    this.animations.push(animation);\n  }\n\n  // Define the render function which is called on the animation event\n  render(delta) {\n\n    // Select the context from the scene\n    const context = this.scene.context;\n\n    // Apply all the animations\n    for (const animation of this.animations) {\n\n      // Run the animation on the mesh\n      animation.animate(this, delta);\n    }\n\n    // Define the model view matrix\n    const modelView = mat4.create();\n\n    // Compute the model view matrix\n    mat4.multiply(modelView, this.scene.camera.view, this.model);\n\n    // Define the normal matrix\n    const normalMatrix = mat4.create();\n\n    // Compute the normal matrix\n    mat4.invert(normalMatrix, modelView);\n    mat4.transpose(normalMatrix, normalMatrix);\n\n    // Update the world transforms\n    context.uniformMatrix4fv(this.material.locations.world, false, this.scene.world);\n\n    // Update the mesh model transforms\n    context.uniformMatrix4fv(this.material.locations.model, false, this.model);\n\n    // Update the camera view\n    context.uniformMatrix4fv(this.material.locations.view, false, this.scene.camera.view);\n\n    // Update the camera projection\n    context.uniformMatrix4fv(this.material.locations.projection, false, this.scene.camera.projection);\n\n    // Update the normal matrix\n    context.uniformMatrix4fv(this.material.locations.normalMatrix, false, normalMatrix); \n\n    // Update the mesh source lighting\n    context.uniform3fv(this.material.locations.light, unit([0, 2, 2]));\n\n    // Update the mesh color\n    context.uniform4fv(this.material.locations.color, [0.8, 0.8, 0.8, 1]);\n\n    // Bind the positions from the buffer\n    context.bindBuffer(context.ARRAY_BUFFER, this.buffers.positions);\n    context.enableVertexAttribArray(this.material.locations.position);\n    context.vertexAttribPointer(this.material.locations.position, 3, context.FLOAT, false, 0, 0);\n\n    // Bind the normals from the buffer\n    context.bindBuffer(context.ARRAY_BUFFER, this.buffers.normals);\n    context.enableVertexAttribArray(this.material.locations.normal);\n    context.vertexAttribPointer(this.material.locations.normal, 3, context.FLOAT, false, 0, 0);\n\n    // Bind the indices from the buffer\n    context.bindBuffer(context.ELEMENT_ARRAY_BUFFER, this.buffers.indices);\n\n    // Draw each of the faces within the mesh\n    context.drawElements(context.TRIANGLES, this.indices.length, context.UNSIGNED_SHORT, 0);\n  }\n}\n;// CONCATENATED MODULE: ./src/modules/animation.js\n// Describe the animation loop\nclass Animation {\n\n  // Desribe the constructor\n  constructor(name, handler) {\n\n    // Bind the name\n    this.name = name;\n\n    // Bind the animation loop\n    this.handler = handler;\n  }\n\n  // Run the animaton\n  animate(model, delta) {\n\n    // Return the animation\n    return this.handler(model, delta);\n  }\n}\n;// CONCATENATED MODULE: ./src/index.js\n// Import the graphics modules\n\n\n\n\n\n\n\n// Export the graphics modules\n\n\n//# sourceURL=webpack://@oneisland/graphics/./src/index.js_+_16_modules?")}},__webpack_require__={d:(n,e)=>{for(var t in e)__webpack_require__.o(e,t)&&!__webpack_require__.o(n,t)&&Object.defineProperty(n,t,{enumerable:!0,get:e[t]})},o:(n,e)=>Object.prototype.hasOwnProperty.call(n,e),r:n=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})}},__webpack_exports__={};return __webpack_modules__[102](0,__webpack_exports__,__webpack_require__),__webpack_exports__})()}));
//# sourceMappingURL=bundle.js.map